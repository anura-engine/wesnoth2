{
	id: "game_controller",
	is_human: true,
	hidden_in_game: true,
	is_strict: true,

	properties: {
		screen_width: "int :: SCREEN_WIDTH",
		screen_height: "int :: SCREEN_HEIGHT",
		player_session_id: "int :: 1",
		ai_session_id: "int :: 2",

		my_turn: "bool :: state.nplayer = state.current_player",

		_pass_button: { type: "null|obj button_controller" },

		pass_turn: "def() ->commands execute(me,
			tbs_send(_client, {
				type: 'pass_turn',
			})
		)",

		update_widgets: "def() ->commands
		if(have_pass_button != if(_pass_button, true, false),
		[
			remove_object(_pass_button),
			if(have_pass_button,
				spawn('button_controller', {
					x: screen_width - lib.wesnoth.py(180),
					y: screen_height - lib.wesnoth.py(50),
					text: 'Pass',
					on_click: me.pass_turn,
					zorder: 1000,
				})
			)
		])
		where have_pass_button = (my_turn and state.unit_moving = null)
		",

		_unit_avatars: { type: "[obj unit_avatar]", default: [] },

		update_unit_avatars: "def() ->commands
		[
			[ remove_object(u) | u <- _unit_avatars, u not in new_unit_avatars],

			[ add_object(u) | u <- new_unit_avatars, u not in _unit_avatars],

			set(_unit_avatars, new_unit_avatars),

			[[set(u.mid_x, tile_mid_x(u.unit.loc)), set(u.mid_y, tile_mid_y(u.unit.loc))] | u <- new_unit_avatars],

			[if(avi != null, avi.animate_movement(anim)) where avi = find(new_unit_avatars, value.unit = anim.unit) | anim <- state.animations, anim is class animation.unit_move],

			if(state.unit_moving and state.unit_moving.controller = state.nplayer,
				start_moving_unit(state.unit_moving)
			),

			[ u.update() | u<- new_unit_avatars],

		] where new_unit_avatars = [obj unit_avatar]<- map(state.units,
			if(existing, existing,
			   object('unit_avatar_' + value.id, {
				  mid_x: tile_mid_x(value.loc),
				  mid_y: tile_mid_y(value.loc),
				  unit: value,
				  controller: me,
			   })
			)
			where existing = find(_unit_avatars, value.unit = context.value))
		",

		_cursor: { type: "obj tile_cursor", init: "object('tile_cursor', {x: 0, y: 0, alpha: 0})" },
		_cursor_loc: { type: "[int,int]", default: [0,0] },

		//The current canonical game state.
		_state: { type: "null|class game_state" },

		state: "class game_state<- _state",

		hex_map: "hex_map <- level.hex_map",

		tile_mid_x: "def(Loc loc) ->int
			hex_map.tile_pixel_pos_from_loc(loc)[0] + hex_map.tile_height/2
		",

		tile_mid_y: "def(Loc loc) ->int
			hex_map.tile_pixel_pos_from_loc(loc)[1] + hex_map.tile_height/2
		",

		//The last state_id of the game that we received from the server.
		_state_id: { type: "int", default: -1 },

		//Our connection to the server.
		_client: { type: "object", init: "tbs_internal_client()" },

		//Unit we are currently moving.
		_moving_unit: { type: "null|obj unit_avatar" },
		_moving_unit_locs: { type: "null|[Loc]" },

		tile_clicked: "def() ->commands execute(me, if(
		my_turn and state.unit_moving and u = state.unit_moving,

			guard_unit(),

		u and u.controller = state.nplayer and state.current_player = state.nplayer and not u.has_moved and not state.unit_moving,
			start_moving_unit(u),

			_moving_unit and (_cursor_loc in _moving_unit_locs),
			[
				tbs_send(_client, {
					type: 'move_unit',
					unit_id: _moving_unit.unit._uuid,
					path: lib.pathfind.find_path_to_loc(state, _moving_unit.unit, _cursor_loc).path,
				}),

				set(_moving_unit, null),
				set(_moving_unit_locs, null),
				if(_move_shader_controller, remove_object(_move_shader_controller)),
				set(_move_shader_controller, null),
				set(level.hex_masks, []),
			],

			[
				set(_moving_unit, null),
				set(_moving_unit_locs, null),
				if(_move_shader_controller, remove_object(_move_shader_controller)),
				set(_move_shader_controller, null),
				set(level.hex_masks, []),
			]

		) where u = state.unit_at_loc(_cursor_loc)
		)",

		guard_unit: "def() ->commands
		execute(me,
		[
			debug('guard_unit'),
			tbs_send(_client, {
				type: 'guard_unit',
			}),

			set(_moving_unit, null),
			set(_moving_unit_locs, null),
			if(_move_shader_controller, remove_object(_move_shader_controller)),
			set(_move_shader_controller, null),
			set(level.hex_masks, []),
		]
		)
		asserting _moving_unit",

		start_moving_unit: "def(class unit u) ->commands

		[
		set(_moving_unit, avi),
		set(_moving_unit_locs, locs),
		if(_move_shader_controller, remove_object(_move_shader_controller)),
		set(_move_shader_controller, null),

		set(level.hex_masks, [{id: 'move', locs: locs}]),
		spawn('hex_shader_controller', { }, [set(_move_shader_controller, child)] ),
		]

		where locs = lib.pathfind.find_paths(state, u)
		where avi = find_or_die(_unit_avatars, value.unit = u)
		",

		_move_shader_controller: { type: "null|obj hex_shader_controller" },

		//Connects to the local server and creates a game.
		create_game: "def() ->commands execute(me, [
			tbs_send(_client, {
				type: 'create_game',
				game_type: 'wesnoth2',
				users: [{
					user: 'human',
					session_id: player_session_id,
					ruler: 'Sorceress',
				}, {
					user: 'ai',
					session_id: ai_session_id,
					bot: true,
					bot_type: 'default',
					ruler: 'Sorceress',
				}],
			})
		])",

		get_game_state_from_delta: "def(int delta_basis, any delta) ->class game_state|null
		if(base_state != null, class game_state<- apply_delta(base_state, delta))

		where base_state = if(_state and _state_id = delta_basis, _state)
		",

		reserve_animation_time: "def(int ncycles) ->commands
			; set(_animation_time, max(_animation_time, ncycles))
		",

		_animation_time: { type: "int", default: 0 },

		_most_recent_state_id_known: "int :: int<- max([_state_id] + map(_game_state_queue, int<- value.state_id))",

		_game_state_queue: { type: "[map]", default: [] },

		handle_game_message: "def(map message) ->commands
		[
			debug(['queue_state', message.state_id]),
			add(_game_state_queue, [message])
		]
		",

		process_game_message: "def(map message) ->commands
		[
		if(message.state_id > _state_id,
		if(new_state is class game_state,
		[
			set(_state_id, int<- message.state_id),

			debug(['process_game', _state_id, message.state_id, size(new_state.animations)]),

			if(_state != null and _state._uuid = new_state._uuid,
				update_object(_state, new_state),
				set(_state, new_state)
			),

			fire_event('show_game_state'),
		], [
			debug('failed to delta state')
		])
		where new_state = if(message.delta, get_game_state_from_delta(int<- message.delta_basis, message.delta), message.state),

		debug(['IGNORE OLD STATE', message.state_id, _state_id])
		),

		]
		",
	},

	on_create: "[
		create_game(),
		
		add_object(_cursor),
		set(_cursor.alpha, 128),

	]",

	on_process: "[
		//pump the network connection.
		tbs_process(_client),

		if(_animation_time > 0,
		   add(_animation_time, -1),
		   _game_state_queue,
		   [

		   map(_game_state_queue,
		       ; if(_animation_time <= 0, [
			   	set(_game_state_queue, filter(_game_state_queue, value != msg)),
				process_game_message(msg),
			   ] where msg = value)),
		   fire_event('request_updates'),
		   ]
		),

		if(level.hex_map and level.player.ctrl_mice and level.player.ctrl_mice[0] is [int,int],
		[
			set(_cursor.xy, level.hex_map.tile_pixel_pos_from_loc(tile_loc)),
			set(_cursor_loc, tile_loc),
		] where tile_loc = level.hex_map.tile_loc_from_pixel_pos([int,int]<- level.player.ctrl_mice[0])
		),
	]",

	on_message_received: "[
	debug(['MESSAGE:', message.type]),
	 switch(message.type,
		'game_created',
		[
			//spawn('background', 256, 256, {zorder: -1}),

			//now that the game has been created, re-create our connection
			//to the server specifying what we have the session ID which
			//corresponds to player 1.
			set(_client, tbs_internal_client(player_session_id)),

			//start requesting updates from the server.
			fire_event('request_updates')
		],

		'game',
		//An update to the game state has come in.
		handle_game_message(message),

	)
	] where message = map<- arg.message",

	//Present the current game state to players.
	on_show_game_state: "if(_state, [
		//[remove_object(xo) | xo<- level.chars, xo is obj xo],

		//map(_state.tiles, spawn('xo', 124 + 136*key[0], 124 + 136*key[1], { state: if(value, 'X', 'O') })),

		if(level.hex_map = null, set(level.hex_map, _state.game_map));

		update_unit_avatars(),

		update_widgets(),
	])",

	//Send a message to the server asking for updates.
	on_request_updates: "if(_client.in_flight = 0,
		tbs_send(_client, {
			type: 'request_updates',
			state_id: _most_recent_state_id_known,
			allow_deltas: true,
		})
	)",
/*
	"on_mouse_down*": "if(cell_x in [0,1,2] and cell_y in [0,1,2] and _state != null and _state.nplayer = _state.current_player, [
		debug(['mouse down ', cell_x, cell_y]),
		tbs_send(_client, {
			type: 'move',
			loc: [cell_x,cell_y],
		})

	]) where cell_x = (mouse_x - 54)/136
	   where cell_y = (mouse_y - 54)/136
	   where mouse_x = int<- arg.mouse_x
	   where mouse_y = int<- arg.mouse_y",
	 */
}
