{
	id: "game_controller",
	is_human: true,
	hidden_in_game: true,
	is_strict: true,

	types: {
		SelectionHandler: "function(obj action_display)->commands",
	},

	properties: {
		screen_width: "int :: SCREEN_WIDTH",
		screen_height: "int :: SCREEN_HEIGHT",

		mouse_pos_abs: "[int,int]<-
		[(int<-level.player.ctrl_mice[0][0]), (int<-level.player.ctrl_mice[0][1])]",

		mouse_pos: "[int,int]<-
		[screen_x + (int<-level.player.ctrl_mice[0][0]), screen_y + (int<-level.player.ctrl_mice[0][1])]",

		player_session_id: "int :: 1",
		ai_session_id: "int :: 2",

		my_turn: "bool :: state.nplayer = state.current_player",

		_pass_button: { type: "null|obj button_controller" },

		pass_turn: "def() ->commands execute(me,
			tbs_send(_client, {
				type: 'pass_turn',
			})
		)",

		create_action_pane: "def(class action a, map args={}, null|SelectionHandler fn=null) ->obj action_display
		obj action_display<-
			if(a is class summon,
				object('summon_display', {
					summon: a,
					controller: me,
					selection_handler: fn,
				} + args),

				a is class attack,
				object('attack_display', {
					attack: a,
					controller: me,
					selection_handler: fn,
				} + args)
			)
		",

		update_widgets: "def() ->commands
		if(have_pass_button != if(_pass_button, true, false),
		[
			remove_object(_pass_button),
			if(have_pass_button,
				spawn('button_controller', {
					x: screen_width - lib.wesnoth.py(180),
					y: screen_height - lib.wesnoth.py(50),
					text: 'Pass',
					on_click: me.pass_turn,
					zorder: lib.zorder.gui_pane + 10,
				})
			)
		])
		where have_pass_button = (my_turn and state.unit_moving = null)
		",

		_animate_summons: "def(class animation.unit_summon info) ->commands
		;

		if(summoner != null and summoned_check = null,
		[
			reserve_animation_time(50),
			summoner.summon_animation(info),
			spawn('unit_avatar_' + info.summoned.id, {
			   mid_x: tile_mid_x(info.summoned.loc),
			   mid_y: tile_mid_y(info.summoned.loc),
			   unit: info.summoned,
			   controller: me,
			   alpha: 0,
			   on_board: false,
			}, [
				add(_unit_avatars, [obj unit_avatar<- child]),
				(obj unit_avatar<- child).summoned_animation(info),
			])

		])
		  where summoner = find(level.chars, value is obj unit_avatar and value.unit = info.summoner)
		  where summoned_check = find(level.chars, value is obj unit_avatar and value.unit = info.summoned)",

		_animate_death: "def(class animation.unit_death info) ->commands
		if(unit, unit.death_animation(info))
			where unit = find(_unit_avatars, value.unit = info.unit)
		",

		_animate_attack: "def(class animation.unit_battle battle_info, int attack_num=0) ->commands
		if(attack_num < size(battle_info.attacks),
		;
		if(attacker != null and defender != null,
		[
		if(info.attacker.loc[0] < info.defender.loc[0],
		   set(attacker.facing, 1),
		   info.attacker.loc[0] > info.defender.loc[0],
		   set(attacker.facing, -1)
		),

		if(info.attack.projectile != null, [
			reserve_animation_time(60),
			attacker.launch_projectile_animation(defender, info.damage),
			schedule(attacker.launch_projectile_impact_point, ; defender.animate_damage(info.damage)),

			schedule(attacker.launch_projectile_delay,
				spawn(info.attack.projectile, {
					controller: me,
					source: attacker,
					target: defender,
				})
			),

			schedule(30, ; _animate_attack(battle_info, attack_num+1)),
		],
		[
			attacker.melee_attack_animation(info, defender, info.damage),
			reserve_animation_time(51),
			schedule(30, ; _animate_attack(battle_info, attack_num+1)),
			schedule(attacker.melee_impact_point, ; defender.animate_damage(info.damage)),
		]
		)

		]
		)

		where attacker = find(_unit_avatars, value.unit = info.attacker)
		where defender = find(_unit_avatars, value.unit = info.defender)
		where info = battle_info.attacks[attack_num]
		)
		",

		_update_game_needed: { type: "bool", default: false },

		_spellbook_pane: { type: "null|obj spellbook_pane" },

		open_spellbook: "def() ->commands
			spawn('spellbook_pane', {
				x: 50,
				y: 50,
				zorder: 10000,
				use_absolute_screen_coordinates: true,
				spellbook: myplayer.spellbook,
				controller: me,
			}, [
				set(_spellbook_pane, child)
			])
		",

		update_game_after_animations: "def() ->commands
		if(_animation_queue or _animation_time > 0,
			set(_update_game_needed, true),

			update_unit_avatars();
			update_widgets();
			if(unit_pane, unit_pane.update());
			set(_update_game_needed, false)
		)
		",

		play_animation: "def(class animation anim) ->commands
		if(anim is class animation.unit_move, 
		     if(avi != null, avi.animate_movement(anim)) where avi = find(_unit_avatars, value.unit = anim.unit),
		   anim is class animation.unit_battle,
		     _animate_attack(anim),
		   anim is class animation.unit_summon,
		     _animate_summons(anim),
		   anim is class animation.unit_death,
		     _animate_death(anim)
		)
		",

		_animation_queue: { type: "[class animation]", default: [] },
		pump_animation_queue: "def() ->commands
		if(_animation_queue, [
			set(_animation_queue, _animation_queue[1:]),
			play_animation(_animation_queue[0]),
		])
		",

		play_animations: "def() ->commands
		[
			set(_animation_queue, state.animations)
		]",

		_unit_avatars: { type: "[obj unit_avatar]", default: [] },

		update_unit_avatars: "def() ->commands
		[
			[ remove_object(u) | u <- _unit_avatars, u not in new_unit_avatars],

			[ add_object(u) | u <- new_unit_avatars, u not in _unit_avatars],

			set(_unit_avatars, new_unit_avatars),

			[[set(u.mid_x, tile_mid_x(u.unit.loc)), set(u.mid_y, tile_mid_y(u.unit.loc))] | u <- new_unit_avatars],

			[ u.update() | u<- new_unit_avatars],

			if(state.unit_moving and state.unit_moving.controller = state.nplayer,
				; start_moving_unit(state.unit_moving)
			),

		] where new_unit_avatars = [obj unit_avatar]<- map(state.units,
			if(existing, existing,
			   object('unit_avatar_' + value.id, {
				  mid_x: tile_mid_x(value.loc),
				  mid_y: tile_mid_y(value.loc),
				  unit: value,
				  controller: me,
			   })
			)
			where existing = find(_unit_avatars, value.unit = context.value))
		",

		_cursor: { type: "obj tile_cursor", init: "object('tile_cursor', {x: 0, y: 0, alpha: 0})" },
		_cursor_loc: { type: "[int,int]", default: [0,0] },

		//The current canonical game state.
		_state: { type: "null|class game_state" },

		state: "class game_state<- _state",
		myplayer: "class player :: state.players[state.nplayer]",

		hex_map: "hex_map <- level.hex_map",

		tile_mid_x: "def(Loc loc) ->int
			hex_map.tile_pixel_pos_from_loc(loc)[0] + hex_map.tile_height/2
		",

		tile_mid_y: "def(Loc loc) ->int
			hex_map.tile_pixel_pos_from_loc(loc)[1] + hex_map.tile_height/2
		",

		//The last state_id of the game that we received from the server.
		_state_id: { type: "int", default: -1 },

		//Our connection to the server.
		_client: { type: "object", init: "tbs_internal_client()" },

		//Unit we are currently moving.
		_moving_unit: { type: "null|obj unit_avatar" },
		_moving_unit_locs: { type: "null|[Loc]" },
		_attacking_unit_locs: { type: "null|[Loc]" },
		_summoning_locs: { type: "null|[Loc]" },

		_moving_arrow: { type: "null|obj arrow", set: "if(_data != value, [remove_object(_data), set(_data, value), set(_moving_arrow_path, null)])" },
		_moving_arrow_path: { type: "null|[Loc]" },

		unit_pane: {
			type: "null|obj unit_pane",
			set: "if(_data != value, [
				remove_object(_data),
				set(_data, value),
			])",
		},

		_process_tile_pos: "def([int,int] loc) ->commands
		[
			if(_moving_unit and _moving_unit_locs and (loc in _moving_unit_locs),
				if(path.path != _moving_arrow_path,
				[
					spawn('arrow', {
						zorder: 1000,
						points: map(path.path, [pos[0] + hex_map.tile_height/2, pos[1] + hex_map.tile_height/2] where pos = hex_map.tile_pixel_pos_from_loc(value)),
					}, [
						set(_moving_arrow, child),
					]),
					set(_moving_arrow_path, path.path),
				])
				where path = lib.pathfind.find_path_to_loc(state, _moving_unit.unit, loc),

				set(_moving_arrow, null)
			),
			
			//set the mouse cursor
			if(my_turn and state.unit_moving and u = state.unit_moving,
				set_mouse_cursor('guard'),
			_moving_unit and _moving_unit_locs and (_cursor_loc in _moving_unit_locs),
				set_mouse_cursor('move'),
			_moving_unit and _attacking_unit_locs and (_cursor_loc in _attacking_unit_locs),
				set_mouse_cursor('attack'),
				set_mouse_cursor('normal')
			)
			where u = state.unit_at_loc(_cursor_loc)
		]
		",

		reset_input: "def() ->commands
		[
			set(_moving_unit, null),
			set(_moving_arrow, null),
			set(_moving_unit_locs, null),
			set(_attacking_unit_locs, null),
			set(_summoning_locs, null),
			if(_move_shader_controller, remove_object(_move_shader_controller)),
			set(_move_shader_controller, null),
			set(level.hex_masks, []),
		]
		",

		debug_unit: "def(string name, null|Loc base_loc=null) ->commands
			if(name not in lib.wesnoth.all_summons(),
			   debug('No such unit'),
			   tbs_send(_client, {
					type: 'debug_unit',
					loc: vacant_loc,
					summon: name,
			   })
			)
			where vacant_loc =
			  find_or_die([[xpos+loc[0],ypos+loc[1]] | xpos<- range(10), ypos<- range(10)],
				state.unit_at_loc(value) = null)
			where loc = if(base_loc != null, base_loc, [4,4])
		",

		pass_spellbook: "def() ->commands
		[
			remove_object(_spellbook_pane),
			set(_spellbook_pane, null),
		]
		",

		memorize: "def(class unit u, class action a) ->commands
		execute(me, [
			tbs_send(_client, {
				type: 'memorize',
				unit_id: u._uuid,
				action_id: a._uuid,
			}),

			remove_object(_spellbook_pane),
			set(_spellbook_pane, null),
		])
		",

		_show_unit_pane: "def(class unit u) ->commands
			spawn('unit_pane', {
				unit: u,
				controller: me,
				x2: SCREEN_WIDTH-10,
				y: 20,
				_width: 180,
				zorder: lib.zorder.gui_pane + 10,
				show_meditate: true,
			}, [
				set(unit_pane, child),
			])
		",

		tile_clicked: "def() ->commands execute(me, [

		if(u and u.controller = state.nplayer and state.unit_moving = null,
			_show_unit_pane(u)
		),
		
		if(
		my_turn and state.unit_moving and u = state.unit_moving,

			guard_unit(),

		u and u.controller = state.nplayer and state.current_player = state.nplayer and u.has_moved < u.num_moves and not state.unit_moving,
			start_moving_unit(u),

			_moving_unit and _summoning_locs and (_cursor_loc in _summoning_locs) and find(level.chars, value is obj summon_display and value.selected) != null,

			[
				tbs_send(_client, {
					type: 'summon_unit',
					unit_id: _moving_unit.unit._uuid,
					loc: _cursor_loc,
					summon: display.summon.name,
				}),

				set(display.selected, false),

				reset_input(),
			]
			where display = find_or_die(level.chars, value is obj summon_display and value.selected),

			_moving_unit and _moving_unit_locs and (_cursor_loc in _moving_unit_locs),
			[
				tbs_send(_client, {
					type: 'move_unit',
					unit_id: _moving_unit.unit._uuid,
					path: lib.pathfind.find_path_to_loc(state, _moving_unit.unit, _cursor_loc).path,
				}),

				reset_input(),
			],

			_moving_unit and u and _attacking_unit_locs and (_cursor_loc in _attacking_unit_locs) and _moving_unit.unit.attacks,
			[
				tbs_send(_client, {
					type: 'attack_unit',
					unit_id: _moving_unit.unit._uuid,
					target_unit_id: u._uuid,
					attack: if(selected_attack, selected_attack.attack.name, _moving_unit.unit.attacks[0].name),
				}),

				reset_input(),
			] where selected_attack = find(level.chars, value is obj attack_display and value.selected),

			state.unit_moving = null,
			[
				set(_moving_unit, null),
				set(_moving_unit_locs, null),
				set(_moving_arrow, null),
				set(_attacking_unit_locs, null),
				set(_summoning_locs, null),
				if(_move_shader_controller, remove_object(_move_shader_controller)),
				set(_move_shader_controller, null),
				set(level.hex_masks, []),
			]

		)
		] where u = state.unit_at_loc(_cursor_loc)
		)",

		guard_unit: "def() ->commands
		execute(me,
		[
			debug('guard_unit'),
			tbs_send(_client, {
				type: 'guard_unit',
			}),

			set(_moving_unit, null),
			set(_moving_unit_locs, null),
			set(_moving_arrow, null),
			set(_attacking_unit_locs, null),
			set(_summoning_locs, null),
			if(_move_shader_controller, remove_object(_move_shader_controller)),
			set(_move_shader_controller, null),
			set(level.hex_masks, []),
		]
		)
		asserting _moving_unit",

		start_summoning: "def(class summon s) ->commands
		if(unit_pane != null,
		[
			set(_moving_unit, find(level.chars, value is obj unit_avatar and value.unit = unit_pane.unit)),
			set(_moving_unit_locs, []),
			set(_moving_arrow, null),
			set(_attacking_unit_locs, []),
			set(_summoning_locs, valid_locs),
			if(_move_shader_controller, remove_object(_move_shader_controller)),
			set(_move_shader_controller, null),

			set(level.hex_masks, [{id: 'move', locs: valid_locs}]),
			spawn('hex_shader_controller', { }, [set(_move_shader_controller, child)] ),
		] where valid_locs = unit_pane.unit.valid_summoning_locs(state)
		)
		",

		start_moving_unit: "def(class unit u) ->commands
		if(not avi,
		[
			set(unit_pane, null),
			reset_input(),
		],

		[
		set(_moving_unit, avi),
		set(_moving_unit_locs, locs),
		set(_moving_arrow, null),
		set(_attacking_unit_locs, target_locs),
		set(_summoning_locs, null),
		if(_move_shader_controller, remove_object(_move_shader_controller)),
		set(_move_shader_controller, null),

		set(level.hex_masks, [{id: 'move', locs: locs + target_locs}]),
		spawn('hex_shader_controller', { }, [set(_move_shader_controller, child)] ),
		]

		where target_locs = map(u.possible_targets(state), value.loc)
		where locs = lib.pathfind.find_paths(state, u)
		)
		where avi = find(_unit_avatars, value.unit = u)
		",

		attack_selected: "def(class unit u) ->commands
		[
			set(_moving_unit_locs, []),
			set(_moving_arrow, null),
			if(_move_shader_controller, remove_object(_move_shader_controller)),
			set(_move_shader_controller, null),

			set(level.hex_masks, [{id: 'move', locs: target_locs}]),
			spawn('hex_shader_controller', { }, [set(_move_shader_controller, child)] ),
		]
		where target_locs = map(u.possible_targets(state), value.loc)
		",

		_move_shader_controller: { type: "null|obj hex_shader_controller" },

		//Connects to the local server and creates a game.
		create_game: "def() ->commands execute(me, [
			tbs_send(_client, {
				type: 'create_game',
				game_type: 'wesnoth2',
				users: [{
					user: 'human',
					session_id: player_session_id,
					ruler: 'Sorceress',
					spellbook: {
						spells: ['Ghost', 'Ghost', 'Ghost', 'Wraith', 'Shadow'],
					},
				}, {
					user: 'ai',
					session_id: ai_session_id,
					bot: true,
					bot_type: 'default',
					ruler: 'Sorceress',
					spellbook: {
						spells: [],
					},
				}],
			})
		])",

		get_game_state_from_delta: "def(int delta_basis, any delta) ->class game_state|null
		if(base_state != null, class game_state<- apply_delta(base_state, delta))

		where base_state = if(_state and _state_id = delta_basis, _state)
		",

		reserve_animation_time: "def(int ncycles) ->commands
			; set(_animation_time, max(_animation_time, ncycles))
		",

		_animation_time: { type: "int", default: 0 },

		_most_recent_state_id_known: "int :: int<- max([_state_id] + map(_game_state_queue, int<- value.state_id))",

		_game_state_queue: { type: "[map]", default: [] },

		handle_game_message: "def(map message) ->commands
		[
			debug(['queue_state', message.state_id]),
			add(_game_state_queue, [message])
		]
		",

		process_game_message: "def(map message) ->commands
		[
		if(message.state_id > _state_id,
		if(new_state is class game_state,
		[
			set(_state_id, int<- message.state_id),

			debug(['process_game', _state_id, message.state_id, size(new_state.animations)]),

			if(_state != null and _state._uuid = new_state._uuid,
				update_object(_state, new_state),
				set(_state, new_state)
			),

			fire_event('show_game_state'),
		], [
			debug('failed to delta state')
		])
		where new_state = if(message.delta, get_game_state_from_delta(int<- message.delta_basis, message.delta), message.state),

		debug(['IGNORE OLD STATE', message.state_id, _state_id])
		),

		]
		",

		screen_x: { type: "int", default: 0, set: "set(_data, clamp(value, 0, level.dimensions[2] - SCREEN_WIDTH))" },
		screen_y: { type: "int", default: 0, set: "set(_data, clamp(value, 0, level.dimensions[3] - SCREEN_HEIGHT))" },

		_sidebar: { type: "null|obj sidebar_pane" },
		_create_sidebar: "def() ->commands
		if(_sidebar = null,
			spawn('sidebar_pane', {
				y: 0,
				x2: SCREEN_WIDTH,
				_width: 200,
				_height: SCREEN_HEIGHT,
				zorder: lib.zorder.gui_pane,
			}, [
				set(_sidebar, child)
			])
		)
		",

		show_turn_banner: "def(int nturn) ->commands
			spawn('label', {
				zorder: 10000,
				_text: ['Round ' + str(nturn)],
				use_absolute_screen_coordinates: true,
				_font_size: 48,
				mid_x: SCREEN_WIDTH/2-100 + 300,
				mid_y: SCREEN_HEIGHT/2,
				alpha: 0,
			}, [
				animate(child, {
					mid_x: SCREEN_WIDTH/2-100,
					alpha: 255,
				}, {
					duration: 20,
				}),

				schedule(70,
					animate(child, {
						mid_x: SCREEN_WIDTH/2-100 - 300,
						alpha: 0,
					}, {
						duration: 20,
						on_complete: remove_object(child),
					})
				)
			])
		",
	},

	events: {

		create: "set(level.dimensions, [0,0,1024*4,768*4]); [
			create_game(),

			_create_sidebar(),
			
			add_object(_cursor),
			set(_cursor.alpha, 255),

		]",

		process: "[

			set(level.camera_position, [screen_x, screen_y]),
			set(level.lock_screen, [screen_x + SCREEN_WIDTH/2, screen_y + SCREEN_HEIGHT/2]),
			//pump the network connection.
			tbs_process(_client),

			if(_spellbook_pane != null,
			   null,
			   _animation_time > 0,
			   add(_animation_time, -1),
			   _animation_queue,
			   pump_animation_queue(),
			   _update_game_needed,
			   update_game_after_animations(),
			   _game_state_queue,
			   [

			   map(_game_state_queue,
				   ; if(_animation_time <= 0 and _animation_queue = [], [
					set(_game_state_queue, filter(_game_state_queue, value != msg)),
					process_game_message(msg),
				   ] where msg = value)),
			   fire_event('request_updates'),
			   ]
			),

			if(level.hex_map and not _spellbook_pane,
			[
				set(_cursor.xy, level.hex_map.tile_pixel_pos_from_loc(tile_loc)),
				set(_cursor_loc, tile_loc),
				_process_tile_pos(tile_loc),
			] where tile_loc = level.hex_map.tile_loc_from_pixel_pos(mouse_pos)
			),

			if(level.player.ctrl_down, add(screen_y, 10)),
			if(level.player.ctrl_up, add(screen_y, -10)),
			if(level.player.ctrl_left, add(screen_x, -10)),
			if(level.player.ctrl_right, add(screen_x, 10)),
		]",

		message_received: "[
		debug(['MESSAGE:', message.type]),
		 switch(message.type,
			'game_created',
			[
				//spawn('background', 256, 256, {zorder: -1}),

				//now that the game has been created, re-create our connection
				//to the server specifying what we have the session ID which
				//corresponds to player 1.
				set(_client, tbs_internal_client(player_session_id)),

				//start requesting updates from the server.
				fire_event('request_updates')
			],

			'game',
			//An update to the game state has come in.
			handle_game_message(message),

		)
		] where message = map<- arg.message",

		//Present the current game state to players.
		"+show_game_state": "if(_state, [
			debug('SHOW GAME STATE'),
			//[remove_object(xo) | xo<- level.chars, xo is obj xo],

			//map(_state.tiles, spawn('xo', 124 + 136*key[0], 124 + 136*key[1], { state: if(value, 'X', 'O') })),

			if(state.nround > 1 and state.previous.nround != state.nround,
				show_turn_banner(state.nround)

			),


			if(level.hex_map = null,
				set(level.hex_map, _state.game_map);
				set(level.dimensions, [0, 0, max(SCREEN_WIDTH, (hex_map.logical.width*hex_map.tile_height*3)/4), max(SCREEN_HEIGHT, hex_map.logical.height*hex_map.tile_height)]),
			);

			set(_state.logical_map, hex_map.logical);

			play_animations();

			update_game_after_animations()
		])",

		//Send a message to the server asking for updates.
		"+request_updates": "if(_client.in_flight = 0,
			tbs_send(_client, {
				type: 'request_updates',
				state_id: _most_recent_state_id_known,
				allow_deltas: true,
			})
		)",
	/*
		"mouse_down*": "if(cell_x in [0,1,2] and cell_y in [0,1,2] and _state != null and _state.nplayer = _state.current_player, [
			debug(['mouse down ', cell_x, cell_y]),
			tbs_send(_client, {
				type: 'move',
				loc: [cell_x,cell_y],
			})

		]) where cell_x = (mouse_x - 54)/136
		   where cell_y = (mouse_y - 54)/136
		   where mouse_x = int<- arg.mouse_x
		   where mouse_y = int<- arg.mouse_y",
		 */
	},
}
