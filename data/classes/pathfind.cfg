{
	find_path_to_loc: "def(class game_state state, class unit u, Loc dst) -> {path: [Loc]}

	{path: path}
		
	where path = [Loc]<- a_star_search(weighted_graph, u.loc, dst, def(Loc a, Loc b) ->decimal distance_between(a, b))
	where weighted_graph = weighted_graph(dir_graph, def(Loc aa, Loc bb) ->decimal u.terrain_entry_cost(logical_map.tile_at(bb).id))
	where dir_graph = directed_graph(possible_locs, def(Loc loc)->[Loc] filter(logical_map.adjacent_tiles(loc), value in possible_locs))
	where possible_locs = logical_map.tiles_in_radius(u.loc, u.move)
	where logical_map = get_logical_map(state.game_map)
	",

	find_paths: "def(class game_state state, class unit u) -> [Loc]
	filter(locs, state.unit_at_loc(value) = null)
	where locs = [Loc]<- path_cost_search(weighted_graph, u.loc, u.move)
	where weighted_graph = weighted_graph(dir_graph, def(Loc aa, Loc bb) ->decimal u.terrain_entry_cost(logical_map.tile_at(bb).id))
	where dir_graph = directed_graph(possible_locs, def(Loc loc)->[Loc] filter(logical_map.adjacent_tiles(loc), value in possible_locs))
	where possible_locs = logical_map.tiles_in_radius(u.loc, u.move)
	where logical_map = get_logical_map(state.game_map)
	",

	get_logical_map: "def(map m) ->logical_map
	query_cache(global_cache(16), m, logical_map<- hex_logical_map(m))
	",

	distance_between: "def(Loc a, Loc b) ->int
	  xdiff + max(0, ydiff - ydiscount)
	    where ydiscount = xdiff/2 + if(a[0]%2 = 0 and b[1] < a[1] or a[0]%2 = 1 and b[1] > a[1], xdiff%2, 0)
		where xdiff = abs(a[0] - b[0])
		where ydiff = abs(a[1] - b[1])
	",

}
