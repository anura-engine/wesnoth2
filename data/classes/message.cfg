{
	properties: {
		type: { variable: true, default: 'message', type: 'string' },
		player: { variable: true, type: 'int' },

		execute: "def(class game_state game) ->commands null",

	},

//Messages that are sent on the network.
classes: [
{
	//A move message, just contains the location we are playing at.
	move: { bases: ['message'], properties: {
		loc: { type: '[int,int]' },
	} },

	pass_turn: { bases: ['message'], properties: {
		execute: "def(class game_state game) ->commands
		game.pass_turn()
		"
	} },

	guard_unit: { bases: ['message'], properties: {
		execute: "def(class game_state game) ->commands
		game.unit_guard()
		"
	} },

	move_unit: { bases: ['message'], properties: {
		unit_id: { type: "string" },
		path: { type: "[Loc]" },
		execute: "def(class game_state game) ->commands
		if(u != null, game.unit_move(u, path),
		              debug('ERROR: could not find unit: ' + unit_id))
			where u = find(game.units, value._uuid = unit_id)
		",
	} },

	attack_unit: { bases: ['message'], properties: {
		unit_id: { type: "string" },
		target_unit_id: { type: "string" },
		attack: { type: "string" },
		execute: "def(class game_state game) ->commands
		if(u != null and target != null and attack_obj != null, game.unit_attack(u, target, attack_obj),
		              debug('ERROR: could not find unit: ' + unit_id))
			where attack_obj = if(u, find(u.attacks, value.name = attack))
			where u = find(game.units, value._uuid = unit_id)
			where target = find(game.units, value._uuid = target_unit_id)
		",
	} },

	summon_unit: { bases: ['message'], properties: {
		unit_id: { type: "string" },
		loc: { type: "Loc" },
		summon: { type: "string" },

		execute: "def(class game_state game) ->commands
		if(u != null and summon_obj != null,
			game.unit_summon(u, loc, summon_obj), 
		)
			where summon_obj = if(u, find(u.summons, value.name = summon))
			where u = find(game.units, value._uuid = unit_id)
		",


	} },

	memorize: { bases: ['message'], properties: {
		unit_id: { type: "string" },
		action_id: { type: "string" },

		execute: "def(class game_state game) ->commands
		if(u != null and a != null and u.memory > 0, [
			game.memorize(p, u, a),
		])

		where a = find(p.spellbook.actions, value._uuid = action_id)
		where u = find(game.units, value._uuid = unit_id)
		where p = game.players[player]
		",
	} },

	debug_unit: { bases: ['message'], properties: {
		loc: { type: "Loc" },
		summon: { type: "string" },

		execute: "def(class game_state game) ->commands

		if(s != null,
		   game.debug_unit(loc, construct('summon', s))
		)
		where s = lib.wesnoth.all_summons()[summon]
		",


	} },


	//The main message the server sends to clients to describe the
	//game state.
	game: { properties: {
		type: { variable: true, default: 'message', type: 'string' },
		id: { type: 'int' },
		server_time: { type: 'int|null' },
		log: { type: 'string' },

		//state_id is an integer which increments every time the game
		//state mutates. The clients should record the game state and
		//use it in request_updates to state which game state they already have.
		state_id: { type: 'int' },

		//The full current game state.
		state: { type: 'class game_state' },

		//The player number that the local player controls.
		nplayer: { type: 'int' },
		game_type: { type: 'string|null' },
		users: { type: '[map]|null' },
		started: { type: 'bool|int' },
		players: { type: '[string]' },
		observer: { type: 'bool', default: false },
		serialized_objects: { type: 'map', default: {} },
		observers: { type: "[string]" },
	} },
}
]
}
