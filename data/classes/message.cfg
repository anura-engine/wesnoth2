{
	properties: {
		type: { variable: true, default: 'message', type: 'string' },

		execute: "def(class game_state game) ->commands null",

	},

//Messages that are sent on the network.
classes: [
{
	//A move message, just contains the location we are playing at.
	move: { bases: ['message'], properties: {
		loc: { type: '[int,int]' },
	} },

	pass_turn: { bases: ['message'], properties: {
		execute: "def(class game_state game) ->commands
		game.pass_turn()
		"
	} },

	guard_unit: { bases: ['message'], properties: {
		execute: "def(class game_state game) ->commands
		game.unit_guard()
		"
	} },

	move_unit: { bases: ['message'], properties: {
		unit_id: { type: "string" },
		path: { type: "[Loc]" },
		execute: "def(class game_state game) ->commands
		if(u != null, game.unit_move(u, path),
		              debug('ERROR: could not find unit: ' + unit_id))
			where u = find(game.units, value._uuid = unit_id)
		",
	} },

	//The main message the server sends to clients to describe the
	//game state.
	game: { bases: ['message'], properties: {
		id: { type: 'int' },
		server_time: { type: 'int|null' },
		log: { type: 'string' },

		//state_id is an integer which increments every time the game
		//state mutates. The clients should record the game state and
		//use it in request_updates to state which game state they already have.
		state_id: { type: 'int' },

		//The full current game state.
		state: { type: 'class game_state' },

		//The player number that the local player controls.
		nplayer: { type: 'int' },
		game_type: { type: 'string|null' },
		users: { type: '[map]|null' },
		started: { type: 'bool|int' },
		players: { type: '[string]' },
		observer: { type: 'bool', default: false },
		serialized_objects: { type: 'map', default: {} },
		observers: { type: "[string]" },
	} },
}
]
}
