{
	//This holds our session with the server
	session_id: { type: "int", default: -1 },

	//The last state ID of the game we received. State ID's go upwards.
	//When we request updates we send the last known state ID we received,
	//and the server will update us if something newer is avilaable.
	_state_id: { type: "int", default: -1 },

	_logical_map: { type: "null|logical_map" },

	//This is the main entry point to the bot. Is called when a message
	//from the server is received. We should respond by adding something
	//to bot.script which controls a response.
	handle_message: "def(map message, object bot) ->commands
		if(message.type = 'game',
		   handle_game_message(message, bot),
		   request_updates(bot)
		)
	",

	handle_game_message: "def(class message.game message, object bot) ->commands
		if(_logical_map = null, [
			set(_logical_map, m),
			set(message.state.logical_map, m),
		] where m = lib.pathfind.get_logical_map(message.state.game_map), [
			set(message.state.logical_map, _logical_map)
		]);
		set(_state_id, message.state_id);
		if(message.state.nplayer = message.state.current_player,
		
		[
			//Is our turn, so make a move.
			if(message.state.unit_moving,
			[
			debug(['BOT_MOVE2', path]),
			add(bot.script, [{
				session_id: session_id,
				send: {
					type: 'move_unit',
					unit_id: message.state.unit_moving._uuid,
					path: path,
				}
			}])
			]
			where path = lib.pathfind.find_path_to_loc(message.state, message.state.unit_moving, target_loc).path
			where target_loc = Loc<- choose(lib.pathfind.find_paths(message.state, message.state.unit_moving)),


			if(u != null,
			[
			debug(['BOT_MOVE', path]),
			add(bot.script, [{
				session_id: session_id,
				send: {
					type: 'move_unit',
					unit_id: u._uuid,
					path: path,
				}
			}])
			]
			where path = lib.pathfind.find_path_to_loc(message.state, u, target_loc).path
			where target_loc = Loc<- choose(lib.pathfind.find_paths(message.state, u)),

			add(bot.script, [{
				session_id: session_id,
				send: {
					type: 'pass_turn',
				}
			}])
			)

			where u = find(message.state.units, value.controller = message.state.current_player and value.has_moved < value.num_moves)
			)
		],

		//not our turn, so don't do anything on this message, just request
		//updates when they are available.
		request_updates(bot)
		)
	",

	//A function which sends a request to ask the server for updates when
	//available, will get a response with updates as needed.
	request_updates: "def(object bot) ->commands
	[
		add(bot.script, [{
			session_id: session_id,
			send: {
				type: 'request_updates',
				state_id: _state_id,
			},
		}]),
	]",
}
