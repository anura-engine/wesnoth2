//This controls the full state of the game.
{
	tiles: { type: "{[int,int] ->bool}", default: {} },
	nplayer: { type: "int", default: 0 },
	current_player: { type: "int", default: 0 },

	is_enemy: "def(int a, int b) ->bool a != b",

	players: { type: "[class player]" },

	units: { type: "[class unit]" },

	unit_moving: { type: "null|class unit" },

	game_map: { type: "map", init: "get_document('data/maps/map8.cfg')" },
	logical_map: { type: "null|logical_map" },
	logical_map_assert: "logical_map<- logical_map",

	begin_new_round: "def() ->commands [
		map(units, value.on_new_round())
	]",

	animations: { type: "[class animation]", default: [] },

	add_animation: "def(class animation anim) ->commands
		add(animations, [anim])
	",

	handle_message: "def(class message msg) ->commands
	msg.execute(me)
	",

	//Receive a move from a player and modify the game state appropriately.
	make_move: "def(class message.move move) ->commands
	if(move.loc not in tiles, [
		set(tiles[move.loc], if(current_player = 0, true, false)),
		set(current_player, (current_player+1)%2),
		set(_passes, 0),
	])
	",

	_passes: { type: "int", default: 0 },

	pass_turn: "def() ->commands
	[
		set(unit_moving, null),
		set(current_player, (current_player+1)%size(players)),

		if(_passes+1 >= size(players), [
			begin_new_round(),
		], [
			add(_passes, 1),
		]),
	]",

	unit_guard: "def() ->commands
	[
		debug(['UNIT_GUARD']),
		set(unit_moving.guard, true),
		set(unit_moving, null),
		set(current_player, (current_player+1)%size(players)),
		set(_passes, 0),
	]
	asserting unit_moving != null
	",

	unit_summon: "def(class unit u, Loc loc, class summon s) ->commands
	if(loc in u.valid_summoning_locs(me) and u.mana >= s.mana_cost and
	   (unit_moving = null and u.has_moved = false or unit_moving = u),
	[
		set(u.guard, false),
		_set_unit_moved(u),
		add(u.mana, -s.mana_cost),
		set(new_unit.controller, u.controller),
		set(new_unit.loc, loc),
		add(units, [new_unit]),
		add_animation(construct('animation.unit_summon', {summoner: u, summoned: new_unit})),
	]
	where new_unit = lib.wesnoth.create_unit(s.name, s.unit)
	)
	",

	unit_move: "def(class unit u, [Loc] path) ->commands
	[
		debug(['MOVE UNIT: ', u._uuid, dest]),
		set(u.loc, dest),
		set(u.guard, false),
		add_animation(construct('animation.unit_move', {unit: u, path: path})),

		_set_unit_moved(u),

	]
		asserting (find(units, value.loc = dest) = null)
		where dest = path[size(path)-1]
		asserting path and (unit_moving = null or unit_moving = u)
	",

	unit_at_loc: "def(Loc loc) ->null|class unit
		find(units, value.loc = loc)
	",

	unit_at_loc_or_die: "def(Loc loc) ->class unit
		class unit<- unit_at_loc(loc)
	",

	unit_attack: "def(class unit u, class unit target, class attack attack) ->commands
	if(target in u.possible_targets(me) and u.mana >= attack.mana_cost,
	[
		target.inflict_combat_damage(u, attack, damage),
		add_animation(construct('animation.unit_attack', {unit: u, target: target, attack: attack, damage: damage})),
		_set_unit_moved(u),

		add(u.mana, -attack.mana_cost),
	] where damage = attack.damage)
	",

	_set_unit_moved: "def(class unit u) ->commands
		if(unit_moving = u, [
			set(unit_moving, null),
			set(current_player, (current_player+1)%size(players)),
			set(_passes, 0),
		], [
			set(unit_moving, u),
			set(u.has_moved, true),
		])
	",
}
