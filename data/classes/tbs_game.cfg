//Class which resides on the server and controls creation of the game
//and manages messages from the client. Holds the actual game state
//in _state and sends this to the client.
{
	create: "def(map msg) ->commands [
		set(_state, construct('game_state', {
			players: player_objs,
			units: map(player_objs, value.ruler),
			buildings: [],
		}));
		if(_state,
			set(_state.logical_map, lib.pathfind.get_logical_map(_state.game_map));
			_state.begin_new_round()
		)
		//currently nothing since games always start the same.
	] where player_objs = map(players, construct('player', {
				name: string<- value.user,
				ruler: lib.wesnoth.create_ruler(string<- value.ruler, {controller: index, loc: if(index = 0, [14,18], [14,4])}),
				spellbook: construct('spellbook', map<- value.spellbook),
	        }))
	  where players = [map]<- msg.users",

	//Must be implemented if we want to support restarting the game
	//in the same server.
	restart: "def() ->commands null",

	//Called several times a second, used if we want to have any
	//real-time updating to our game such as time controls.
	process: "def() ->commands null",

	//Called when a mesage is received from a player.
	message: "def(map message, int player) ->commands
	debug(['MESSAGE FROM PLAYER: ', player, message]);
		if((player = state.current_player or message.type = 'memorize') and not message.execute, [
			//increments our state_id which signifies the game has changed
			//in a significant way and the game must be synced to clients.
			add(_game.state_id, 1),

			set(state.animations, []),

			//tell the game to implement move logic.
			state.handle_message(class message<- construct('message.' + (string<- message.type), message + {player: player}))
		])
	",

	//Add a bot to the game. The real bot logic is in the 'bot' class.
	//this has some handlers which delegates the real thinking into
	//the bot class
	add_bot: "def(int session_id, string bot_type, any args, any bot_args) ->commands [
		add(_game.state_id, 1),
		add(_game.bots, [{
			session_id: session_id,
			script: [{
				session_id: session_id,
				send: {
					type: 'request_updates'
				}
			}],

			on_create: 'set(data, construct(q(bot), {session_id: ' + str(session_id) + '}))',
			on_message: q(data.handle_message(message, me)),
		}]),
	]",

	//This should be implemented to message clients and say someone has
	//disconnected from the game.
	player_disconnected: "def() ->commands null",

	//This is used before sending a message to the player to transform the
	//game state based on what the client should know about. 'doc' will get
	//the returned value from get_state(). We should modify it to suit
	//the given client. For instance we might want to remove FoW elements
	//that the player shouldn't know about.
	transform: "def(object doc, int nplayer) ->commands [set(doc.nplayer, nplayer), set(doc.logical_map, null)]",

	//This is used by the engine to restore the state. Is currently only
	//used for debugging.
	restore_state: "def(object new_state) ->commands
		set(_state, new_state) asserting new_state is class game_state
	",

	//This is what the engine uses to query us for the current game state.
	get_state: "def() ->class game_state state",

	state: "class game_state<- _state",
	_state: { type: "null|class game_state" },

	player_waiting_on: "def() ->int|null
	if(_state, _state.current_player)
	",

	//This is our interface to the engine. The server's game object. It
	//will be initialized by the engine.
	_game: { type: "game" },
}
